%% title: Exploiting Perl 6 Mixins For Fun And Profit
%% date: 2016-06-27
%% desc: Mixing in roles into core objects to inject malicious code from a distance
%% draft: True

Back when I wrote about [exploiting operators made of invisible Unicode
characters](http://perl6.party/post/Anguish--Invisible-Programming-Language-and-Invisible-Data-Theft),
a bunch of folks pointed out the module containing rogue
code would actually have to be imported by the victim. Fair enough. Today,
we'll play a new game and step it up a notch!

## The Game Plan

We all worked on codebases that relied on a dozen of open-sourced modules,
each of which relied on a few more, which in turn relied on... well, you get
the point. Somewhere, a gazillion levels deep, there's some type of a
[leftpad](http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) in use
that you never review for sanity. Right?

So here's our setup:

    +--------------+     +-------------+    +------------+
    | Rightpad.pm6 |  -> | GoodGuy.pm6 | -> | Target.pm6 |
    +--------------+     +-------------+    +------------+

`Target.pm6` is some code we want to steal stuff from. It uses
`GoodGuy.pm6` to bring in some functionality, and somewhere down
`GoodGuy.pm6`'s dependency chain there's `Rightpad.pm6` that we'll
use to inject rogue code into and hope no one will notice.

In particular, we have these goals:

1) Inject code that will steal data that's being operated on by `Target.pm6`.
For this game, we'll assume it's credit card numbers.
2) The exploit has to be as invisible as possible. We're free to modify
`Rightpad.pm6` anywaywe want, but `Target.pm6`'s and `GoodGuy.pm6`'s code has
to remain exactly the same, functioning, and with as few signs of foul play as
possible.

First, let's review a couple of methods of injecting code and then play
around with the actual code to inject. Just for fun. Let's begin!

## Augmented Reality

The first thing one might think about when trying to change stuff in the
entire app is core type augmentation. Let's try it out:

    use MONKEY-TYPING;
    augment class Str { method uc {} }

    # OUTPUT:
    # ===SORRY!=== Error while compiling /home/zoffix/CPANPRC/temp.p6
    # Package 'Str' already has a method 'uc' (did you mean to declare
    # a multi-method?)
    # at /home/zoffix/CPANPRC/temp.p6:2

We enable the `MONKEY-TYPING` pragma to acknowledge we're doing Dangerous
Thingsâ„¢ and then try to replace an already-existing `uc` method on `Str` type.

Oops! We get an error saying it already exists and we can't replace it.
However, we do get a hint for how we can cheat: a multi.
We just have to get creative and make a multi that'll hijack the
dispatch to the method we're trying to... um... hijack.

    use MONKEY-TYPING;
    augment class Str {
        multi method uc (Str $str where * :) {
            say "We're in! Someone's trying to uppercase $str";
            nextsame;
        }
    }

    say 'foo'.uc;

    # OUTPUT:
    # We're in! Someone's trying to uppercase foo
    # FOO

It worked! We prefix the method definition with `multi` to indicate it's
a multi-dispatch method. For the invocant, we add a type constraint with
`where` in the signature, except the condition is just the Whatever Star, which
will always match any `Str`. The benefit is the dispatch will actually pick
this method as the type constraint indicates that it should be narrower than
normal `Str`.

Lastly, to retain the original functionality of the method we're hijacking,
we simply use `nextsame` to re-dispatch to the next multi, which would be
the original method that will make the target code behave as it was meant to.

## Mixing It Up

Augmentation is great, but it's a blunt tool. We can get more precision by
mixing in roles into core objects:

    'foo' does role {
        method uc {
            say "We're in! Someone's trying to uppercase {self}";
            callsame;
        }
    };

    say 'foo'.uc;

    # OUTPUT:
    # We're in! Someone's trying to uppercase foo
    # FOO

Here, we're doing a runtime mixin with an anonymous role

use soft;
&put.wrap(sub (| is raw) {say "We're here!"; callsame});
