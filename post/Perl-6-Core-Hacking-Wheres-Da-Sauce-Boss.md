%% title: Perl 6 Core Hacking: Where's Da Sauce, Boss?
%% date: 2016-08-03
%% desc: Locating the source code for specific core methods and subs
%% draft: True

Imagine you were playing with Perl 6 and you came across a bugglet
or you were having some fun with [the Perl 6 bug
queue](http://rakudo.org/rt/open-all)—you'd like to debug a particular core
subroutine or method, so where's the source for it at?

Asked such a question, you might be told it's in [Rakudo compiler's
GitHub repository](rakudo.org/downloads/rakudo/). Depending on how deep
down the rabit hole you wish to go, you may also stop by [NQP's
repo](https://github.com/perl6/nqp), which is a subset of Perl 6 that's used
in Rakudo, or the [MoarVM's repo](https://github.com/MoarVM/MoarVM), which
is the leading virtual machine Perl 6 runs on.

The answer is fine, but we can do better. We'd like to know *exactly* where
da sauce is.

## Stick to The Basics

The most obvious way is to just use `grep` command in the source repository.
The code is likely in `src/` directory, or `src/core` more specifically.

We'll use a regex that catches `sub`, `method`, and `multi` keywords. For
example, here's our search for `path` sub or method:

    $ grep -ER '^\s*(multi|sub|method|multi sub|multi method)\s+path' src/core

    src/core/Cool.pm:    method path() { self.Stringy.IO }
    src/core/CompUnit/Repository/Locally.pm:    method path-spec(CompUnit::Repository::Locally:D:) {
    src/core/CompUnit/Repository/AbsolutePath.pm:    method path-spec() {
    src/core/CompUnit/Repository/NQP.pm:    method path-spec() {
    src/core/CompUnit/Repository/Perl5.pm:    method path-spec() {
    src/core/CompUnit/PrecompilationStore/File.pm:    method path(CompUnit::PrecompilationId $compiler-id,
    src/core/CompUnit/PrecompilationUnit.pm:    method path(--> IO::Path) { ... }
    src/core/IO/Spec/Win32.pm:    method path {
    src/core/IO/Spec/Unix.pm:    method path {
    src/core/IO/Handle.pm:    method path(IO::Handle:D:)            { $!path.IO }

It's not too terrible, but it's a rather blunt tool. We have these problems:

* There are no line numbers, so we'd have to search the individual files for
the methods
* There are false positives; we have several `path-spec` methods found
* It doesn't tell us which of the results is for the actual method we have in
our code. There's `Cool`, `IO::Spec::Unix`, and `IO::Handle` all with
`method path` in them. If I call `"foo".IO.path`, which of those get called?

The last one is particularly irksome, but luckily Perl 6 can tell us where
the source is from. Let's ask it!

## But here's line number... So code me maybe

The `Code` class from which all subs and methods inherit provides
`.file` and `.line` methods that tell which file that particular `Code` is
defined in, including the line number:

    say "The code is in {.file} on line {.line}" given &foo;

    sub foo {
        say 'Hello world!';
    }

    # OUTPUT:
    # The code is in test.p6 on line 3

That looks nice and simple, but it gets more awkward with methods:

    class Kitty {
        method meow {
            say 'Meow world!';
        }
    }

    say "The code is in {.file} on line {.line}" given Kitty.^can('meow')[0];

    # OUTPUT:
    # The code is in test.p6 on line 2

We got extra cruft of the `.^can` metamodel call, which returns a list of
`Method` objects. Above we use the first one to get the `.file` and
`.line` number from, but is it really the method we were looking for?
Take a look at this example:

    class Cudly {
        method meow ('meow', 'meow') {
            say 'Meow meow meow!';
        }
    }

    class Kitty is Cudly {
        multi method meow ('world') {
            say 'Meow world!';
        }

        multi method meow ('meow') {
            say 'Meow meow';
        }
    }

We have a method `meow` in one class and in another class we have two
`multi method`s `meow`. How can we print the location of the last method,
the one that takes a single `'meow'` as an argument?

First, let's take a gander at all the items `.^can` returns:

    say Kitty.^can('meow');
    # OUTPUT:
    # (meow meow)

Wait a minute, we have three methods in our code, so how come we only have
two meows in the output? Let's print the `.file` and `.line` for both meows:

    for 0, 1 {
        say "The code is in {.file} on line {.line}"
            given Kitty.^can('meow')[$_];
    }
    # OUTPUT:
    # The code is in gen/moar/m-CORE.setting on line 587
    # The code is in test.p6 on line 2

The second `meow` gives us a sane result; it's our method defined in
class `Cudly`. The first one, however, gives some weird file.

What's happening here is the line is referencing the `proto` for the multies.
Since in this case instead of providing a `proto` we use the autogenerated
one, the referenced file has nothing to do with our code. We can, of course,
add a proto into the code, but then the line number would still reference
the proto, not the last `meow` method. Is there anything that we can do?

## You `.cando` It!

The `Routine` class, from which both `Method` and `Sub` classes inherit,
provides the `.cando` method. Given a
[`Capture`](https://docs.perl6.org/type/Capture), it returns the best
matching candidate, and since the returned object is a `Code`, we can quiery
its specific `.file` and `.line`:


    class Cudly {
        method meow ('meow', 'meow') {
            say 'Meow meow meow!';
        }
    }

    class Kitty is Cudly {
        multi method meow ('world') {
            say 'Meow world!';
        }

        multi method meow ('meow') {
            say 'Meow meow';
        }
    }

    my $code = gather {
        for Kitty.^can('meow') -> $meth {
            .take for grep *.defined, $meth.cando: \(Kitty, 'meow');
        }
    }

    say "The code is in {.file} on line {.line}" with $code[0];

    # OUTPUT:
    # The code is in test.p6 on line 12

Hooray! We got the correct locations for the multi we wanted. We still have
our two classes with three `meow` methods total. On line 17–21 we loop
over the two `meow` `Method`s the `.^can` metamodel call gives us. For
each of them we call the `.cando` method with the `Capture` that matches
the multi we want (note that we do need to provide the needed object as the
first argument of the Capture). We `grep` the return for all the `.defined`
values that we `.take` to `gather` into the `$code` variable.

The first value we get is the narrowest candidate and is good 'nuf for us,
so we call the `.file` and `.line` on it, which gives us the location we were
looking for. Sounds like we nailed this `.file` and `.line` business down
rather well. Let's dive into the core, shall we?

## Can't see the core files for the setting

Have you tried printing out the `.file`/`.line` for some core stuff yet?
You're in for surprise. Actually, we've already seen the surprise, but you
may have thought it to be a fluke:

    say "{.file}:{.line}" given &say;
    # OUTPUT:
    # gen/moar/m-CORE.setting:29038

All of the [nice, good looking
files](https://github.com/rakudo/rakudo/tree/nom/src/core) you see in
`src/core` in the repo actually get compiled into one giant file called
the "setting." My current setting is 40,952 lines long and the `.line` of core
subs and methods refers to one of those thousands of lines.

Now sure, we could pop the setting open and watch our editor grind to a
stuttering halt (I'm looking at *you,* [Atom](https://atom.io/)!). However,
that doesn't help us find the right repo file to edit if we want to make
changes to how it works. So what do we do?

A keen eye will look at the contents of the setting or [at the file
that generates it](https://github.com/rakudo/rakudo/blob/nom/tools/build/gen-cat.nqp) and notice that for each of the [separate files in the
repo](https://github.com/rakudo/rakudo/tree/nom/src/core), the setting has
this type of comment before the contents of the file are inserted into the
setting:

    #line 1 src/core/core_prologue.pm

This means if we're clever enough, we can write a sub that translates
a line number in the setting to the separate file we can locate in the repo.
Here's a plan of action: we pop open the setting file and read it line by line.
When we encounter one of the above comments, we make a note of which file
we're in as well as how many lines deep we're in that file.

The location of the setting file may differ, depending on how you installed
Perl 6, but on my system (I use
[`rakudobrew`](https://github.com/tadzik/rakudobrew)), it's in
`$*EXECUTABLE.parent.parent.parent.child('gen/moar/m-CORE.setting')`, so the
code for finding the actual file our core sub or method is defined in is this:

    sub real-location-for ($wanted) {
        state $setting = $*EXECUTABLE.parent.parent.parent.child: 'gen/moar/m-CORE.setting';
        my ($cur-line-num, $offset) = 0, 0;
        my $file;
        for $setting.IO.lines -> $line {
            return %( :$file, :line($cur-line-num - $offset), )
                if ++$cur-line-num == $wanted;

            if $line ~~ /^ '#line 1 ' $<file>=\S+/ {
                $file   = $<file>;
                $offset = $cur-line-num + 1;
            }
        };
        fail 'Were not able to find location in setting.';
    }

    say "{.<file>}:{.<line>}" given real-location-for &say.line;


    # OUTPUT:
    # src/core/io_operators.pm:17

The `$wanted` contains the setting line number `$cur-line-num` contains the
current number we're examining. We loop until the `$cur-line-num` reaches
`$wanted` and return a `Hash` with the results. For each line that matches our
special comment, we store the real name of the file the code is from into
`$file` and store the `$offset` of the first line of code in that file. Once
done, we simply subtract the `$offset` from the setting
`$cur-line-num` and we get the line number in the source file.

This is pretty awesome and useful, but it's still not what I had in mind
when I said we wanted to know *exactly* where da sauce is. I don't want
to clone the repo and go to the repo and open my editor. I want to just look
at code.

## If it's worth doing, it's worth overdoing

There's one place where we can stare at rakudo's source code until it blushes
and looks away: [GitHub](https://github.com/rakudo/rakudo/). Since our handy
sub gives us a filename and a line number, we can construct a URL that points
to a specific file and line in source code, like this one, for example:
[https://github.com/rakudo/rakudo/blob/nom/src/core/Str.pm#L16](https://github.com/rakudo/rakudo/blob/nom/src/core/Str.pm#L16)

There's an obvious problem with such an approach: the URL points to the master
branch (called `nom`, for *"New Object Model,"* in Rakudo). Commits go into
the repo daily, and unless we rebuild our Perl 6 several times a day, there's
a good chance the location our GitHub URL points to is wrong.

Not only do we have to point to a specific file and line number, we have to
point to the right commit too. On GitHub's end, it's easy: we just replace
`nom` in the URL with the appropriate commit number—we just need Rakudo to
tell us what that number is.

The two dynamic variables `$*VM` and `$*PERL` contain some juicy information.
By introspecting them, we can see some useful info and what looks like commit
prefix parts in version numbers:

    say $*VM.^methods
    # (BUILD platform-library-name Str gist config prefix precomp-ext
    # precomp-target precomp-dir name auth version signature desc)

    say $*VM.version
    # v2016.06

    say $*PERL.^methods
    # (BUILD VMnames DISTROnames KERNELnames Str gist compiler name auth version
    # signature desc)

    say $*PERL.compiler.^methods
    # (BUILD build-date Str gist id release codename name auth version
    # signature desc)

    say $*PERL.compiler.version
    # v2016.06.10.g.7.cff.429

Rakudo is a compiler and so we're insterested in the value of
`$*PERL.compiler.version`. It contains the major release version, followed by
`g`, followed by the commit prefix of this particular build. The prefix is
split up on number-letter boundaries, so we'll need to join up all the bits and
split on `g`. But, take a look at `$*VM.version`. There aren't any `g`s and
commits and for a good reason: it's the tagged major release. The same will
occur for Rakudo on release builds, like the ones shipped with
[Rakudo Star](http://rakudo.org/). So we'll need to check for such edge cases
and this is the code:

    my $where = .Str ~~ /g/
        ?? .parts.join.split("g")[*-1]
        !! .Str
    given $*PERL.compiler.version;

`given` a `$*PERL` `.compiler` `.version`, if it contains letter `g`, join up
version bits, split on `g`, and the last portion will be our commit prefix; if
it doesn't contain letter `g`, then we're dealing with a release tag, so we'll
take it as-is. All said and done, our code for locating source becomes this:

    my $where = .Str ~~ /g/
        ?? .parts.join.split("g")[*-1]
        !! .Str
    given $*PERL.compiler.version;

    say [~] 'https://github.com/rakudo/rakudo/blob/',
            $where, '/', .<file>, '#L', .<line>
    given real-location-for &say.line;

    # OUTPUT:
    # https://github.com/rakudo/rakudo/blob/c843682/src/core/io_operators.pm#L17

Hey! Awesome! We got a link that points to the correct commit and file! Let
celebrations begin! Wait. What? You followed the link and noticed the line
number is not quite right? What gives? Did we mess up our algorithm?

## Crank Up The Insanity

If you take a look again at the [script that generates the setting
file](https://github.com/rakudo/rakudo/blob/nom/tools/build/gen-cat.nqp),
you'll notice it strips things: comments and special backend-specific chunks
of code.

There are two ways to fix this. The sane approach would be to commit a change
that would make that script insert an empty line for each line it skips and
then pretend that I didn't do that just to make my personal project work.
Then, there's the Zoffix Way to fix this: we got the GitHub link, so why
don't we fetch that code and figure out what the right line number is. Hey!
That second way sounds much more fun! Let's do just that!

The one link we've seen so far is this:
[https://github.com/rakudo/rakudo/blob/c843682/src/core/io_operators.pm#L17](https://github.com/rakudo/rakudo/blob/c843682/src/core/io_operators.pm#L17).
It's not quite what we want, since it's got HTML and bells and whistles in it.
We want raw code and GitHub does offer that at a slightly different URL:
[https://raw.githubusercontent.com/rakudo/rakudo/c843682/src/core/io_operators.pm](https://raw.githubusercontent.com/rakudo/rakudo/c843682/src/core/io_operators.pm). The plan of action then
becomes:

* Get the line number in the setting
* Use our `real-location-for` sub to get the filename and sorta-right line
number in a source file
* Get the commit our compiler was built with
* Generate a GitHub URL for raw code for that file on that commit
and fetch that code
* Use the same algorithm as in the [setting generating
script](https://github.com/rakudo/rakudo/blob/nom/tools/build/gen-cat.nqp#L28-L45) to convert the code we fetched into the version that lives in our setting,
while keeping track of the number of lines we strip
* When we reach the correct line number in the converted file, we adjust
the original line number we had by the number of lines we stripped
* Generate a regular GitHub URL to the commit, file, and corrected line number
* ???
* Profit!

I could go over the code, but it's just a dumb, unfun algorithm, and most
importantly, you don't need to know it. Because... there's a module that
does just that!

## What Sorcery Is This?

The module is called
[CoreHackers::Sourcery](https://github.com/zoffixznet/perl6-CoreHackers-Sourcery) and when you `use` it, it'll
[`augment`](https://docs.perl6.org/syntax/augment) the `Code` class and
all core classes that inherit from it with `.sourcery` method, as well
as provide a `sourcery` subroutine.

So, to get the location of the code for `say` sub, just run:

    use CoreHackers::Sourcery;
    &say.sourcery.say;

    # OUTPUT:
    # src/core/io_operators.pm:20 https://github.com/rakudo/rakudo/blob/c843682/src/core/io_operators.pm#L20

That gives us the correct location of the `proto`. Want to get the location
of a specific multi? There's no need to mess with `.cando`! The arguments you
give to the `.sourcery` method will be used to select the best matching multi,
so to find the location of the `say` multi that will handle `say "foo"` call,
just run:

    &say.sourcery("foo").say;

    # OUTPUT:
    # src/core/io_operators.pm:22 https://github.com/rakudo/rakudo/blob/c843682/src/core/io_operators.pm#L22

That covers the subs. For methods, you can go with the whole `.^can` meta
dance, but we like simple things, and so we'll use the subroutine form
of `sourcery`:

    say sourcery Int, 'abs';      # method called on a type object
    say sourcery 42,  'split';    # method called on an Int object
    say sourcery 42,  'base', 16; # method call with args

This is pretty handy. And the whole hitting the GitHub thing? The module
will cache the code fetched from GitHub, so things like this won't take
forever:

    say "Int.{.name} is at {.sourcery}" for Int.^methods;
