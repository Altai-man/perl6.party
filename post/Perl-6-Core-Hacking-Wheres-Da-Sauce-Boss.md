%% title: Perl 6 Core Hacking: Where's Da Sauce, Boss?
%% date: 2016-08-03
%% desc: Locating the source code for specific core methods and subs
%% draft: True

Imagine you were playing with Perl 6 and you came across a bugglet
or you were having some fun with [the Perl 6 bug
queue](http://rakudo.org/rt/open-all)—you'd like to debug a particular core
subroutine or method, so where's the source for it at?

Asked such a question, you might be told it's in [Rakudo compiler's
GitHub repository](rakudo.org/downloads/rakudo/). Depending on how deep
down the rabit hole you wish to go, you may also stop by [NQP's
repo](https://github.com/perl6/nqp), which is a subset of Perl 6 that's used
in Rakudo, or the [MoarVM's repo](https://github.com/MoarVM/MoarVM), which
is the leading virtual machine Perl 6 runs on.

The answer is fine, but we can do better. We'd like to know *exactly* where
da sauce is.

## Stick to The Basics

The most obvious way is to just use `grep` command in the source repository.
The code is likely in `src/` directory, or `src/core` more specifically.

We'll use a regex that catches `sub`, `method`, and `multi` keywords. For
example, here's our search for `path` sub or method:

    $ grep -ER '^\s*(multi|sub|method|multi sub|multi method)\s+path' src/core

    src/core/Cool.pm:    method path() { self.Stringy.IO }
    src/core/CompUnit/Repository/Locally.pm:    method path-spec(CompUnit::Repository::Locally:D:) {
    src/core/CompUnit/Repository/AbsolutePath.pm:    method path-spec() {
    src/core/CompUnit/Repository/NQP.pm:    method path-spec() {
    src/core/CompUnit/Repository/Perl5.pm:    method path-spec() {
    src/core/CompUnit/PrecompilationStore/File.pm:    method path(CompUnit::PrecompilationId $compiler-id,
    src/core/CompUnit/PrecompilationUnit.pm:    method path(--> IO::Path) { ... }
    src/core/IO/Spec/Win32.pm:    method path {
    src/core/IO/Spec/Unix.pm:    method path {
    src/core/IO/Handle.pm:    method path(IO::Handle:D:)            { $!path.IO }

It's not too terrible, but it's a rather blunt tool. We have these problems:

* There are no line numbers, so we'd have to search the individual files for
the methods
* There are false positives; we have several `path-spec` methods found
* It doesn't tell us which of the results is for the actual method we have in
our code. There's `Cool`, `IO::Spec::Unix`, and `IO::Handle` all with
`method path` in them. If I call `"foo".IO.path`, which of those get called?

The last one is particularly irksome, but luckily Perl 6 can tell us where
the source is from. Let's ask it!

## But here's line number... So code me maybe

The `Code` class from which all subs and methods inherit provides
`.file` and `.line` methods that tell which file that particular `Code` is
defined in, including the line number:

    say "The code is in {.file} on line {.line}" given &foo;

    sub foo {
        say 'Hello world!';
    }

    # OUTPUT:
    # The code is in test.p6 on line 3

That looks nice and simple, but it gets more awkward with methods:

    class Kitty {
        method meow {
            say 'Meow world!';
        }
    }

    say "The code is in {.file} on line {.line}" given Kitty.^can('meow')[0];

    # OUTPUT:
    # The code is in test.p6 on line 2

We got extra cruft of the `.^can` metamodel call, which returns a list of
`Method` objects. Above we use the first one to get the `.file` and
`.line` number from, but is it really the method we were looking for?
Take a look at this example:

    class Cudly {
        method meow ('meow', 'meow') {
            say 'Meow meow meow!';
        }
    }

    class Kitty is Cudly {
        multi method meow ('world') {
            say 'Meow world!';
        }

        multi method meow ('meow') {
            say 'Meow meow';
        }
    }

We have a method `meow` in one class and in another class we have two
`multi method`s `meow`. How can we print the location of the last method,
the one that takes a single `'meow'` as an argument?

First, let's take a gander at all the items `.^can` returns:

    say Kitty.^can('meow');
    # OUTPUT:
    # (meow meow)

Wait a minute, we have three methods in our code, so how come we only have
two meows in the output? Let's print the `.file` and `.line` for both meows:

    for 0, 1 {
        say "The code is in {.file} on line {.line}"
            given Kitty.^can('meow')[$_];
    }
    # OUTPUT:
    # The code is in gen/moar/m-CORE.setting on line 587
    # The code is in test.p6 on line 2

The second `meow` gives us a sane result; it's our method defined in
class `Cudly`. The first one, however, gives some weird file.

What's happening here is the line is referencing the `proto` for the multies.
Since in this case instead of providing a `proto` we use the autogenerated
one, the referenced file has nothing to do with our code. We can, of course,
add a proto into the code, but then the line number would still reference
the proto, not the last `meow` method. Is there anything that we can do?

## You `.cando` It!

The `Routine` class, from which both `Method` and `Sub` classes inherit,
provides the `.cando` method. Given a
[`Capture`](https://docs.perl6.org/type/Capture), it returns the best
matching candidate, and since the returned object is a `Code`, we can quiery
its specific `.file` and `.line`:


    class Cudly {
        method meow ('meow', 'meow') {
            say 'Meow meow meow!';
        }
    }

    class Kitty is Cudly {
        multi method meow ('world') {
            say 'Meow world!';
        }

        multi method meow ('meow') {
            say 'Meow meow';
        }
    }

    my $code = gather {
        for Kitty.^can('meow') -> $meth {
            .take for grep *.defined, $meth.cando: \(Kitty, 'meow');
        }
    }

    say "The code is in {.file} on line {.line}" with $code[0];

    # OUTPUT:
    # The code is in test.p6 on line 12

Hooray! We got the correct locations for the multi we wanted. We still have
our two classes with three `meow` methods total. On line 17–21 we loop
over the two `meow` `Method`s the `.^can` metamodel call gives us. For
each of them we call the `.cando` method with the `Capture` that matches
the multi we want (note that we do need to provide the needed object as the
first argument of the Capture). We `grep` the return for all the `.defined`
values that we `.take` to `gather` into the `$code` variable.

The first value we get is the narrowest candidate and is good 'nuf for us,
so we call the `.file` and `.line` on it, which gives us the location we were
looking for. Sounds like we nailed this `.file` and `.line` business down
rather well. Let's dive into the core, shall we?

## Can't see the core files for the setting

Have you tried printing out the `.file`/`.line` for some core stuff yet?
You're in for surprise. Actually, we've already seen the surprise, but you
may have thought it to be a fluke:

    say "{.file}:{.line}" given &say;
    # OUTPUT:
    # gen/moar/m-CORE.setting:29038

All of the [nice, good looking
files](https://github.com/rakudo/rakudo/tree/nom/src/core) you see in
`src/core` in the repo actually get compiled into one giant file called
the "setting." My current setting is 40,952 lines long and the `.line` of core
subs and methods refers to one of those thousands of lines.

Now sure, we could pop the setting open and watch our editor grind to a
stuttering halt (I'm looking at *you,* [Atom](https://atom.io/)!). However,
that doesn't help us find the right repo file to edit if we want to make
changes to how it works. So what do we do?

A keen eye will look at the contents of the setting or [at the file
that generates it](https://github.com/rakudo/rakudo/blob/nom/tools/build/gen-cat.nqp) and notice that for each of the [separate files in the
repo](https://github.com/rakudo/rakudo/tree/nom/src/core), the setting has
this type of comment before the contents of the file are inserted into the
setting:

    #line 1 src/core/core_prologue.pm

This means if we're clever enough, we can write a sub that translates
a line number in the setting to the separate file we can locate in the repo.
Here's a plan of action: we pop open the setting file and read it line by line.
When we encounter one of the above comments, we make a note of which file
we're in as well as how many lines deep we're in that file.

The location of the setting file may differ, depending on how you installed
Perl 6, but on my system (I use
[`rakudobrew`](https://github.com/tadzik/rakudobrew)), it's in
`$*EXECUTABLE.parent.parent.parent.child('gen/moar/m-CORE.setting')`, so the
code for finding the actual file our core sub or method is defined in is this:

    sub real-location-for (&code) {
        my $wanted = &code.line;
        my $line-num = 0;
        my $file;
        my $offset;
        for $*EXECUTABLE.parent.parent.parent.child(&code.file).IO.lines -> $line {
            $line-num++;
            return { :$file, :line($line-num - $offset), } if $line-num == $wanted;
            if $line ~~ /^ '#line 1 ' $<file>=\S+/ {
                $file = $<file>;
                $offset = $line-num+1;
            }
        };

        fail 'Were not able to find location in setting. Are you sure this is'
            ~ ' a core Code?';
    }

    say "{.<file>}:{.<line>}" given real-location-for &say;

    # OUTPUT:
    # src/core/io_operators.pm:17

The `$wanted` contains the setting line number `$line-num` contains the
current number we're examining. We loop until the `$line-num` reaches `$wanted`
and return a `Hash` with the results. For each line that matches our
special comment, we store the real name of the file the code is from into
`$file` and store the `$offset` of the first line of code in that file. Once
done, we simply subtract the `$offset` from the setting `$line-num` and we get
the line number in the source file.

This is pretty awesome and useful, but it's still not what I had in mind
when I said we wanted to know *exactly* where da sauce is. I don't want
to clone the repo and go to the repo and open my editor. I want to just look
at code.

## If it's worth doing, it's worth overdoing